{"ast":null,"code":"// index.ts\nimport { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\nfunction angle(startPoint, midPoint, endPoint) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n  const azimuthOA = bearingToAzimuth(options.mercator !== true ? bearing(O, A) : rhumbBearing(O, A));\n  let azimuthOB = bearingToAzimuth(options.mercator !== true ? bearing(O, B) : rhumbBearing(O, B));\n  if (azimuthOB < azimuthOA) {\n    azimuthOB = azimuthOB + 360;\n  }\n  const angleAOB = azimuthOB - azimuthOA;\n  if (options.explementary === true) {\n    return 360 - angleAOB;\n  }\n  return angleAOB;\n}\nvar turf_angle_default = angle;\nexport { angle, turf_angle_default as default };","map":{"version":3,"names":["bearing","bearingToAzimuth","isObject","rhumbBearing","angle","startPoint","midPoint","endPoint","options","arguments","length","undefined","Error","A","O","B","azimuthOA","mercator","azimuthOB","angleAOB","explementary","turf_angle_default"],"sources":["C:\\Users\\nzhvania\\Desktop\\navigate-geography\\node_modules\\@turf\\angle\\index.ts"],"sourcesContent":["import { bearing } from \"@turf/bearing\";\nimport { bearingToAzimuth, Coord, isObject } from \"@turf/helpers\";\nimport { rhumbBearing } from \"@turf/rhumb-bearing\";\n\n/**\n * Finds the angle formed by two adjacent segments defined by 3 points. The result will be the (positive clockwise)\n * angle with origin on the `startPoint-midPoint` segment, or its explementary angle if required.\n *\n * @function\n * @param {Coord} startPoint Start Point Coordinates\n * @param {Coord} midPoint Mid Point Coordinates\n * @param {Coord} endPoint End Point Coordinates\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.explementary=false] Returns the explementary angle instead (360 - angle)\n * @param {boolean} [options.mercator=false] if calculations should be performed over Mercator or WGS84 projection\n * @returns {number} Angle between the provided points, or its explementary.\n * @example\n * turf.angle([5, 5], [5, 6], [3, 4]);\n * //=45\n */\nfunction angle(\n  startPoint: Coord,\n  midPoint: Coord,\n  endPoint: Coord,\n  options: {\n    explementary?: boolean;\n    mercator?: boolean;\n  } = {}\n): number {\n  // Optional Parameters\n  if (!isObject(options)) {\n    throw new Error(\"options is invalid\");\n  }\n\n  // Validation\n  if (!startPoint) {\n    throw new Error(\"startPoint is required\");\n  }\n  if (!midPoint) {\n    throw new Error(\"midPoint is required\");\n  }\n  if (!endPoint) {\n    throw new Error(\"endPoint is required\");\n  }\n\n  // Rename to shorter variables\n  const A = startPoint;\n  const O = midPoint;\n  const B = endPoint;\n\n  // Main\n  const azimuthOA = bearingToAzimuth(\n    options.mercator !== true ? bearing(O, A) : rhumbBearing(O, A)\n  );\n  let azimuthOB = bearingToAzimuth(\n    options.mercator !== true ? bearing(O, B) : rhumbBearing(O, B)\n  );\n  // If OB \"trails\" OA advance OB one revolution so we get the clockwise angle.\n  if (azimuthOB < azimuthOA) {\n    azimuthOB = azimuthOB + 360;\n  }\n  const angleAOB = azimuthOB - azimuthOA;\n\n  // Explementary angle\n  if (options.explementary === true) {\n    return 360 - angleAOB;\n  }\n  return angleAOB;\n}\n\nexport { angle };\nexport default angle;\n"],"mappings":";AAAA,SAASA,OAAA,QAAe;AACxB,SAASC,gBAAA,EAAyBC,QAAA,QAAgB;AAClD,SAASC,YAAA,QAAoB;AAkB7B,SAASC,MACPC,UAAA,EACAC,QAAA,EACAC,QAAA,EAKQ;EAAA,IAJRC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAGI,CAAC;EAGL,IAAI,CAACP,QAAA,CAASM,OAAO,GAAG;IACtB,MAAM,IAAII,KAAA,CAAM,oBAAoB;EACtC;EAGA,IAAI,CAACP,UAAA,EAAY;IACf,MAAM,IAAIO,KAAA,CAAM,wBAAwB;EAC1C;EACA,IAAI,CAACN,QAAA,EAAU;IACb,MAAM,IAAIM,KAAA,CAAM,sBAAsB;EACxC;EACA,IAAI,CAACL,QAAA,EAAU;IACb,MAAM,IAAIK,KAAA,CAAM,sBAAsB;EACxC;EAGA,MAAMC,CAAA,GAAIR,UAAA;EACV,MAAMS,CAAA,GAAIR,QAAA;EACV,MAAMS,CAAA,GAAIR,QAAA;EAGV,MAAMS,SAAA,GAAYf,gBAAA,CAChBO,OAAA,CAAQS,QAAA,KAAa,OAAOjB,OAAA,CAAQc,CAAA,EAAGD,CAAC,IAAIV,YAAA,CAAaW,CAAA,EAAGD,CAAC,CAC/D;EACA,IAAIK,SAAA,GAAYjB,gBAAA,CACdO,OAAA,CAAQS,QAAA,KAAa,OAAOjB,OAAA,CAAQc,CAAA,EAAGC,CAAC,IAAIZ,YAAA,CAAaW,CAAA,EAAGC,CAAC,CAC/D;EAEA,IAAIG,SAAA,GAAYF,SAAA,EAAW;IACzBE,SAAA,GAAYA,SAAA,GAAY;EAC1B;EACA,MAAMC,QAAA,GAAWD,SAAA,GAAYF,SAAA;EAG7B,IAAIR,OAAA,CAAQY,YAAA,KAAiB,MAAM;IACjC,OAAO,MAAMD,QAAA;EACf;EACA,OAAOA,QAAA;AACT;AAGA,IAAOE,kBAAA,GAAQjB,KAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}