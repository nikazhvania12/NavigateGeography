{"ast":null,"code":"// index.ts\nimport { centroid } from \"@turf/centroid\";\nimport { getCoord } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\nfunction pNormDistance(feature1, feature2) {\n  let p = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  const coordinate1 = getCoord(feature1);\n  const coordinate2 = getCoord(feature2);\n  const xDiff = coordinate1[0] - coordinate2[0];\n  const yDiff = coordinate1[1] - coordinate2[1];\n  if (p === 1) {\n    return Math.abs(xDiff) + Math.abs(yDiff);\n  }\n  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);\n}\nfunction distanceWeight(fc, options) {\n  var _a, _b;\n  options = options || {};\n  const threshold = options.threshold || 1e4;\n  const p = options.p || 2;\n  const binary = (_a = options.binary) != null ? _a : false;\n  const alpha = options.alpha || -1;\n  const rowTransform = (_b = options.standardization) != null ? _b : false;\n  const features = [];\n  featureEach(fc, feature => {\n    features.push(centroid(feature));\n  });\n  const weights = [];\n  for (let i = 0; i < features.length; i++) {\n    weights[i] = [];\n  }\n  for (let i = 0; i < features.length; i++) {\n    for (let j = i; j < features.length; j++) {\n      if (i === j) {\n        weights[i][j] = 0;\n      }\n      const dis = pNormDistance(features[i], features[j], p);\n      weights[i][j] = dis;\n      weights[j][i] = dis;\n    }\n  }\n  for (let i = 0; i < features.length; i++) {\n    for (let j = 0; j < features.length; j++) {\n      const dis = weights[i][j];\n      if (dis === 0) {\n        continue;\n      }\n      if (binary) {\n        if (dis <= threshold) {\n          weights[i][j] = 1;\n        } else {\n          weights[i][j] = 0;\n        }\n      } else {\n        if (dis <= threshold) {\n          weights[i][j] = Math.pow(dis, alpha);\n        } else {\n          weights[i][j] = 0;\n        }\n      }\n    }\n  }\n  if (rowTransform) {\n    for (let i = 0; i < features.length; i++) {\n      const rowSum = weights[i].reduce((sum, currentVal) => {\n        return sum + currentVal;\n      }, 0);\n      for (let j = 0; j < features.length; j++) {\n        weights[i][j] = weights[i][j] / rowSum;\n      }\n    }\n  }\n  return weights;\n}\nvar turf_distance_weight_default = distanceWeight;\nexport { turf_distance_weight_default as default, distanceWeight, pNormDistance };","map":{"version":3,"names":["centroid","getCoord","featureEach","pNormDistance","feature1","feature2","p","arguments","length","undefined","coordinate1","coordinate2","xDiff","yDiff","Math","abs","pow","distanceWeight","fc","options","_a","_b","threshold","binary","alpha","rowTransform","standardization","features","feature","push","weights","i","j","dis","rowSum","reduce","sum","currentVal","turf_distance_weight_default"],"sources":["C:\\Users\\nzhvania\\Desktop\\navigate-geography\\node_modules\\@turf\\distance-weight\\index.ts"],"sourcesContent":["import { Feature, FeatureCollection, Point } from \"geojson\";\nimport { centroid } from \"@turf/centroid\";\nimport { getCoord } from \"@turf/invariant\";\nimport { featureEach } from \"@turf/meta\";\n\n/**\n * calcualte the Minkowski p-norm distance between two features.\n *\n * @function\n * @param feature1 point feature\n * @param feature2 point feature\n * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance\n */\nfunction pNormDistance(\n  feature1: Feature<Point>,\n  feature2: Feature<Point>,\n  p = 2\n): number {\n  const coordinate1 = getCoord(feature1);\n  const coordinate2 = getCoord(feature2);\n  const xDiff = coordinate1[0] - coordinate2[0];\n  const yDiff = coordinate1[1] - coordinate2[1];\n  if (p === 1) {\n    return Math.abs(xDiff) + Math.abs(yDiff);\n  }\n  return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);\n}\n\n/**\n *\n *\n * @function\n * @param {FeatureCollection<any>} fc FeatureCollection.\n * @param {Object} [options] option object.\n * @param {number} [options.threshold=10000] If the distance between neighbor and\n * target features is greater than threshold, the weight of that neighbor is 0.\n * @param {number} [options.p=2] Minkowski p-norm distance parameter.\n * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.\n * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.\n *  If false, weight=Math.pow(d, alpha).\n * @param {number} [options.alpha=-1] distance decay parameter.\n * A big value means the weight decay quickly as distance increases.\n * @param {boolean} [options.standardization=false] row standardization.\n * @returns {Array<Array<number>>} distance weight matrix.\n * @example\n *\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var result = turf.distanceWeight(dataset);\n */\nfunction distanceWeight(\n  fc: FeatureCollection<any>,\n  options?: {\n    threshold?: number;\n    p?: number;\n    binary?: boolean;\n    alpha?: number;\n    standardization?: boolean;\n  }\n): number[][] {\n  options = options || {};\n  const threshold = options.threshold || 10000;\n  const p = options.p || 2;\n  const binary = options.binary ?? false;\n  const alpha = options.alpha || -1;\n  const rowTransform = options.standardization ?? false;\n\n  const features: Array<Feature<Point>> = [];\n  featureEach(fc, (feature) => {\n    features.push(centroid(feature));\n  });\n\n  // computing the distance between the features\n  const weights: number[][] = [];\n  for (let i = 0; i < features.length; i++) {\n    weights[i] = [];\n  }\n\n  for (let i = 0; i < features.length; i++) {\n    for (let j = i; j < features.length; j++) {\n      if (i === j) {\n        weights[i][j] = 0;\n      }\n      const dis = pNormDistance(features[i], features[j], p);\n      weights[i][j] = dis;\n      weights[j][i] = dis;\n    }\n  }\n\n  // binary or distance decay\n  for (let i = 0; i < features.length; i++) {\n    for (let j = 0; j < features.length; j++) {\n      const dis: number = weights[i][j];\n      if (dis === 0) {\n        continue;\n      }\n      if (binary) {\n        if (dis <= threshold) {\n          weights[i][j] = 1.0;\n        } else {\n          weights[i][j] = 0.0;\n        }\n      } else {\n        if (dis <= threshold) {\n          weights[i][j] = Math.pow(dis, alpha);\n        } else {\n          weights[i][j] = 0.0;\n        }\n      }\n    }\n  }\n\n  if (rowTransform) {\n    for (let i = 0; i < features.length; i++) {\n      const rowSum = weights[i].reduce((sum: number, currentVal: number) => {\n        return sum + currentVal;\n      }, 0);\n      for (let j = 0; j < features.length; j++) {\n        weights[i][j] = weights[i][j] / rowSum;\n      }\n    }\n  }\n\n  return weights;\n}\n\nexport { pNormDistance, distanceWeight };\nexport default distanceWeight;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}