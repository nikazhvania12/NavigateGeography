{"ast":null,"code":"// index.ts\nimport { convex } from \"@turf/convex\";\nimport { centroid } from \"@turf/centroid\";\nimport { point } from \"@turf/helpers\";\nimport { getType, getCoord } from \"@turf/invariant\";\nimport { coordEach } from \"@turf/meta\";\nfunction centerOfMass(geojson) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (getType(geojson)) {\n    case \"Point\":\n      return point(getCoord(geojson), options.properties);\n    case \"Polygon\":\n      var coords = [];\n      coordEach(geojson, function (coord) {\n        coords.push(coord);\n      });\n      var centre = centroid(geojson, {\n        properties: options.properties\n      });\n      var translation = centre.geometry.coordinates;\n      var sx = 0;\n      var sy = 0;\n      var sArea = 0;\n      var i, pi, pj, xi, xj, yi, yj, a;\n      var neutralizedPoints = coords.map(function (point2) {\n        return [point2[0] - translation[0], point2[1] - translation[1]];\n      });\n      for (i = 0; i < coords.length - 1; i++) {\n        pi = neutralizedPoints[i];\n        xi = pi[0];\n        yi = pi[1];\n        pj = neutralizedPoints[i + 1];\n        xj = pj[0];\n        yj = pj[1];\n        a = xi * yj - xj * yi;\n        sArea += a;\n        sx += (xi + xj) * a;\n        sy += (yi + yj) * a;\n      }\n      if (sArea === 0) {\n        return centre;\n      } else {\n        var area = sArea * 0.5;\n        var areaFactor = 1 / (6 * area);\n        return point([translation[0] + areaFactor * sx, translation[1] + areaFactor * sy], options.properties);\n      }\n    default:\n      var hull = convex(geojson);\n      if (hull) return centerOfMass(hull, {\n        properties: options.properties\n      });else return centroid(geojson, {\n        properties: options.properties\n      });\n  }\n}\nvar turf_center_of_mass_default = centerOfMass;\nexport { centerOfMass, turf_center_of_mass_default as default };","map":{"version":3,"names":["convex","centroid","point","getType","getCoord","coordEach","centerOfMass","geojson","options","arguments","length","undefined","properties","coords","coord","push","centre","translation","geometry","coordinates","sx","sy","sArea","i","pi","pj","xi","xj","yi","yj","a","neutralizedPoints","map","point2","area","areaFactor","hull","turf_center_of_mass_default"],"sources":["C:\\Users\\nzhvania\\Desktop\\navigate-geography\\node_modules\\@turf\\center-of-mass\\index.ts"],"sourcesContent":["import { Feature, GeoJsonProperties, Point, Position } from \"geojson\";\nimport { convex } from \"@turf/convex\";\nimport { centroid } from \"@turf/centroid\";\nimport { point } from \"@turf/helpers\";\nimport { getType, getCoord } from \"@turf/invariant\";\nimport { coordEach } from \"@turf/meta\";\n\n/**\n * Takes any {@link Feature} or a {@link FeatureCollection} and returns its [center of mass](https://en.wikipedia.org/wiki/Center_of_mass) using this formula: [Centroid of Polygon](https://en.wikipedia.org/wiki/Centroid#Centroid_of_polygon).\n *\n * @function\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] Translate Properties to Feature\n * @returns {Feature<Point>} the center of mass\n * @example\n * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);\n *\n * var center = turf.centerOfMass(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, center]\n */\nfunction centerOfMass<P extends GeoJsonProperties = GeoJsonProperties>(\n  geojson: any,\n  options: {\n    properties?: P;\n  } = {}\n): Feature<Point, P> {\n  switch (getType(geojson)) {\n    case \"Point\":\n      return point(getCoord(geojson), options.properties);\n    case \"Polygon\":\n      var coords: Position[] = [];\n      coordEach(geojson, function (coord) {\n        coords.push(coord);\n      });\n\n      // First, we neutralize the feature (set it around coordinates [0,0]) to prevent rounding errors\n      // We take any point to translate all the points around 0\n      var centre = centroid(geojson, { properties: options.properties });\n      var translation = centre.geometry.coordinates;\n      var sx = 0;\n      var sy = 0;\n      var sArea = 0;\n      var i, pi, pj, xi, xj, yi, yj, a;\n\n      var neutralizedPoints = coords.map(function (point) {\n        return [point[0] - translation[0], point[1] - translation[1]];\n      });\n\n      for (i = 0; i < coords.length - 1; i++) {\n        // pi is the current point\n        pi = neutralizedPoints[i];\n        xi = pi[0];\n        yi = pi[1];\n\n        // pj is the next point (pi+1)\n        pj = neutralizedPoints[i + 1];\n        xj = pj[0];\n        yj = pj[1];\n\n        // a is the common factor to compute the signed area and the final coordinates\n        a = xi * yj - xj * yi;\n\n        // sArea is the sum used to compute the signed area\n        sArea += a;\n\n        // sx and sy are the sums used to compute the final coordinates\n        sx += (xi + xj) * a;\n        sy += (yi + yj) * a;\n      }\n\n      // Shape has no area: fallback on turf.centroid\n      if (sArea === 0) {\n        return centre;\n      } else {\n        // Compute the signed area, and factorize 1/6A\n        var area = sArea * 0.5;\n        var areaFactor = 1 / (6 * area);\n\n        // Compute the final coordinates, adding back the values that have been neutralized\n        return point(\n          [translation[0] + areaFactor * sx, translation[1] + areaFactor * sy],\n          options.properties\n        );\n      }\n    default:\n      // Not a polygon: Compute the convex hull and work with that\n      var hull = convex(geojson);\n\n      if (hull) return centerOfMass(hull, { properties: options.properties });\n      // Hull is empty: fallback on the centroid\n      else return centroid(geojson, { properties: options.properties });\n  }\n}\n\nexport { centerOfMass };\nexport default centerOfMass;\n"],"mappings":";AACA,SAASA,MAAA,QAAc;AACvB,SAASC,QAAA,QAAgB;AACzB,SAASC,KAAA,QAAa;AACtB,SAASC,OAAA,EAASC,QAAA,QAAgB;AAClC,SAASC,SAAA,QAAiB;AAkB1B,SAASC,aACPC,OAAA,EAImB;EAAA,IAHnBC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAEI,CAAC;EAEL,QAAQN,OAAA,CAAQI,OAAO;IACrB,KAAK;MACH,OAAOL,KAAA,CAAME,QAAA,CAASG,OAAO,GAAGC,OAAA,CAAQI,UAAU;IACpD,KAAK;MACH,IAAIC,MAAA,GAAqB,EAAC;MAC1BR,SAAA,CAAUE,OAAA,EAAS,UAAUO,KAAA,EAAO;QAClCD,MAAA,CAAOE,IAAA,CAAKD,KAAK;MACnB,CAAC;MAID,IAAIE,MAAA,GAASf,QAAA,CAASM,OAAA,EAAS;QAAEK,UAAA,EAAYJ,OAAA,CAAQI;MAAW,CAAC;MACjE,IAAIK,WAAA,GAAcD,MAAA,CAAOE,QAAA,CAASC,WAAA;MAClC,IAAIC,EAAA,GAAK;MACT,IAAIC,EAAA,GAAK;MACT,IAAIC,KAAA,GAAQ;MACZ,IAAIC,CAAA,EAAGC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,EAAA,EAAIC,CAAA;MAE/B,IAAIC,iBAAA,GAAoBlB,MAAA,CAAOmB,GAAA,CAAI,UAAUC,MAAA,EAAO;QAClD,OAAO,CAACA,MAAA,CAAM,CAAC,IAAIhB,WAAA,CAAY,CAAC,GAAGgB,MAAA,CAAM,CAAC,IAAIhB,WAAA,CAAY,CAAC,CAAC;MAC9D,CAAC;MAED,KAAKM,CAAA,GAAI,GAAGA,CAAA,GAAIV,MAAA,CAAOH,MAAA,GAAS,GAAGa,CAAA,IAAK;QAEtCC,EAAA,GAAKO,iBAAA,CAAkBR,CAAC;QACxBG,EAAA,GAAKF,EAAA,CAAG,CAAC;QACTI,EAAA,GAAKJ,EAAA,CAAG,CAAC;QAGTC,EAAA,GAAKM,iBAAA,CAAkBR,CAAA,GAAI,CAAC;QAC5BI,EAAA,GAAKF,EAAA,CAAG,CAAC;QACTI,EAAA,GAAKJ,EAAA,CAAG,CAAC;QAGTK,CAAA,GAAIJ,EAAA,GAAKG,EAAA,GAAKF,EAAA,GAAKC,EAAA;QAGnBN,KAAA,IAASQ,CAAA;QAGTV,EAAA,KAAOM,EAAA,GAAKC,EAAA,IAAMG,CAAA;QAClBT,EAAA,KAAOO,EAAA,GAAKC,EAAA,IAAMC,CAAA;MACpB;MAGA,IAAIR,KAAA,KAAU,GAAG;QACf,OAAON,MAAA;MACT,OAAO;QAEL,IAAIkB,IAAA,GAAOZ,KAAA,GAAQ;QACnB,IAAIa,UAAA,GAAa,KAAK,IAAID,IAAA;QAG1B,OAAOhC,KAAA,CACL,CAACe,WAAA,CAAY,CAAC,IAAIkB,UAAA,GAAaf,EAAA,EAAIH,WAAA,CAAY,CAAC,IAAIkB,UAAA,GAAad,EAAE,GACnEb,OAAA,CAAQI,UACV;MACF;IACF;MAEE,IAAIwB,IAAA,GAAOpC,MAAA,CAAOO,OAAO;MAEzB,IAAI6B,IAAA,EAAM,OAAO9B,YAAA,CAAa8B,IAAA,EAAM;QAAExB,UAAA,EAAYJ,OAAA,CAAQI;MAAW,CAAC,OAEjE,OAAOX,QAAA,CAASM,OAAA,EAAS;QAAEK,UAAA,EAAYJ,OAAA,CAAQI;MAAW,CAAC;EACpE;AACF;AAGA,IAAOyB,2BAAA,GAAQ/B,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}