{"ast":null,"code":"// index.ts\nimport { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\nfunction cleanCoords(geojson) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson);\n  var newCoords = [];\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson, type);\n      break;\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line, type));\n      });\n      break;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons) {\n        var polyPoints = [];\n        polygons.forEach(function (ring) {\n          polyPoints.push(cleanLine(ring, type));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n    case \"Point\":\n      return geojson;\n    case \"MultiPoint\":\n      var existing = {};\n      getCoords(geojson).forEach(function (coord) {\n        var key = coord.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n    default:\n      throw new Error(type + \" geometry not supported\");\n  }\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n    return {\n      type,\n      coordinates: newCoords\n    };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n    return feature({\n      type,\n      coordinates: newCoords\n    }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id\n    });\n  }\n}\nfunction cleanLine(line, type) {\n  var points = getCoords(line);\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n  var newPoints = [];\n  var secondToLast = points.length - 1;\n  var newPointsLength = newPoints.length;\n  newPoints.push(points[0]);\n  for (var i = 1; i < secondToLast; i++) {\n    var prevAddedPoint = newPoints[newPoints.length - 1];\n    if (points[i][0] === prevAddedPoint[0] && points[i][1] === prevAddedPoint[1]) continue;else {\n      newPoints.push(points[i]);\n      newPointsLength = newPoints.length;\n      if (newPointsLength > 2) {\n        if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n      }\n    }\n  }\n  newPoints.push(points[points.length - 1]);\n  newPointsLength = newPoints.length;\n  if ((type === \"Polygon\" || type === \"MultiPolygon\") && equals(points[0], points[points.length - 1]) && newPointsLength < 4) {\n    throw new Error(\"invalid polygon\");\n  }\n  if (type === \"LineString\" && newPointsLength < 3) {\n    return newPoints;\n  }\n  if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2])) newPoints.splice(newPoints.length - 2, 1);\n  return newPoints;\n}\nfunction equals(pt1, pt2) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\nfunction isPointOnLineSegment(start, end, point) {\n  var x = point[0],\n    y = point[1];\n  var startX = start[0],\n    startY = start[1];\n  var endX = end[0],\n    endY = end[1];\n  var dxc = x - startX;\n  var dyc = y - startY;\n  var dxl = endX - startX;\n  var dyl = endY - startY;\n  var cross = dxc * dyl - dyc * dxl;\n  if (cross !== 0) return false;else if (Math.abs(dxl) >= Math.abs(dyl)) return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nvar turf_clean_coords_default = cleanCoords;\nexport { cleanCoords, turf_clean_coords_default as default };","map":{"version":3,"names":["feature","getCoords","getType","cleanCoords","geojson","options","arguments","length","undefined","mutate","Error","type","newCoords","cleanLine","forEach","line","push","polygons","polyPoints","ring","existing","coord","key","join","Object","prototype","hasOwnProperty","call","coordinates","geometry","properties","bbox","id","points","equals","newPoints","secondToLast","newPointsLength","i","prevAddedPoint","isPointOnLineSegment","splice","pt1","pt2","start","end","point","x","y","startX","startY","endX","endY","dxc","dyc","dxl","dyl","cross","Math","abs","turf_clean_coords_default"],"sources":["C:\\Users\\nzhvania\\Desktop\\navigate-geography\\node_modules\\@turf\\clean-coords\\index.ts"],"sourcesContent":["import { Position } from \"geojson\";\nimport { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n\n// To-Do => Improve Typescript GeoJSON handling\n\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @function\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(\n  geojson: any,\n  options: {\n    mutate?: boolean;\n  } = {}\n) {\n  // Backwards compatible with v4.0\n  var mutate = typeof options === \"object\" ? options.mutate : options;\n  if (!geojson) throw new Error(\"geojson is required\");\n  var type = getType(geojson);\n\n  // Store new \"clean\" points in this Array\n  var newCoords = [];\n\n  switch (type) {\n    case \"LineString\":\n      newCoords = cleanLine(geojson, type);\n      break;\n    case \"MultiLineString\":\n    case \"Polygon\":\n      getCoords(geojson).forEach(function (line) {\n        newCoords.push(cleanLine(line, type));\n      });\n      break;\n    case \"MultiPolygon\":\n      getCoords(geojson).forEach(function (polygons: any) {\n        var polyPoints: Position[] = [];\n        polygons.forEach(function (ring: Position[]) {\n          polyPoints.push(cleanLine(ring, type));\n        });\n        newCoords.push(polyPoints);\n      });\n      break;\n    case \"Point\":\n      return geojson;\n    case \"MultiPoint\":\n      var existing: Record<string, true> = {};\n      getCoords(geojson).forEach(function (coord: any) {\n        var key = coord.join(\"-\");\n        if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n          newCoords.push(coord);\n          existing[key] = true;\n        }\n      });\n      break;\n    default:\n      throw new Error(type + \" geometry not supported\");\n  }\n\n  // Support input mutation\n  if (geojson.coordinates) {\n    if (mutate === true) {\n      geojson.coordinates = newCoords;\n      return geojson;\n    }\n    return { type: type, coordinates: newCoords };\n  } else {\n    if (mutate === true) {\n      geojson.geometry.coordinates = newCoords;\n      return geojson;\n    }\n    return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n      bbox: geojson.bbox,\n      id: geojson.id,\n    });\n  }\n}\n\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @param {string} type Type of geometry\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line: Position[], type: string) {\n  var points = getCoords(line);\n  // handle \"clean\" segment\n  if (points.length === 2 && !equals(points[0], points[1])) return points;\n\n  var newPoints = [];\n  var secondToLast = points.length - 1;\n  var newPointsLength = newPoints.length;\n\n  newPoints.push(points[0]);\n  for (var i = 1; i < secondToLast; i++) {\n    var prevAddedPoint = newPoints[newPoints.length - 1];\n    if (\n      points[i][0] === prevAddedPoint[0] &&\n      points[i][1] === prevAddedPoint[1]\n    )\n      continue;\n    else {\n      newPoints.push(points[i]);\n      newPointsLength = newPoints.length;\n      if (newPointsLength > 2) {\n        if (\n          isPointOnLineSegment(\n            newPoints[newPointsLength - 3],\n            newPoints[newPointsLength - 1],\n            newPoints[newPointsLength - 2]\n          )\n        )\n          newPoints.splice(newPoints.length - 2, 1);\n      }\n    }\n  }\n  newPoints.push(points[points.length - 1]);\n  newPointsLength = newPoints.length;\n\n  // (Multi)Polygons must have at least 4 points, but a closed LineString with only 3 points is acceptable\n  if (\n    (type === \"Polygon\" || type === \"MultiPolygon\") &&\n    equals(points[0], points[points.length - 1]) &&\n    newPointsLength < 4\n  ) {\n    throw new Error(\"invalid polygon\");\n  }\n\n  if (type === \"LineString\" && newPointsLength < 3) {\n    return newPoints;\n  }\n\n  if (\n    isPointOnLineSegment(\n      newPoints[newPointsLength - 3],\n      newPoints[newPointsLength - 1],\n      newPoints[newPointsLength - 2]\n    )\n  )\n    newPoints.splice(newPoints.length - 2, 1);\n\n  return newPoints;\n}\n\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1: Position, pt2: Position) {\n  return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start: Position, end: Position, point: Position) {\n  var x = point[0],\n    y = point[1];\n  var startX = start[0],\n    startY = start[1];\n  var endX = end[0],\n    endY = end[1];\n\n  var dxc = x - startX;\n  var dyc = y - startY;\n  var dxl = endX - startX;\n  var dyl = endY - startY;\n  var cross = dxc * dyl - dyc * dxl;\n\n  if (cross !== 0) return false;\n  else if (Math.abs(dxl) >= Math.abs(dyl))\n    return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n  else return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\n\nexport { cleanCoords };\nexport default cleanCoords;\n"],"mappings":";AACA,SAASA,OAAA,QAAe;AACxB,SAASC,SAAA,EAAWC,OAAA,QAAe;AAsBnC,SAASC,YACPC,OAAA,EAIA;EAAA,IAHAC,OAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAEI,CAAC;EAGL,IAAIG,MAAA,GAAS,OAAOJ,OAAA,KAAY,WAAWA,OAAA,CAAQI,MAAA,GAASJ,OAAA;EAC5D,IAAI,CAACD,OAAA,EAAS,MAAM,IAAIM,KAAA,CAAM,qBAAqB;EACnD,IAAIC,IAAA,GAAOT,OAAA,CAAQE,OAAO;EAG1B,IAAIQ,SAAA,GAAY,EAAC;EAEjB,QAAQD,IAAA;IACN,KAAK;MACHC,SAAA,GAAYC,SAAA,CAAUT,OAAA,EAASO,IAAI;MACnC;IACF,KAAK;IACL,KAAK;MACHV,SAAA,CAAUG,OAAO,EAAEU,OAAA,CAAQ,UAAUC,IAAA,EAAM;QACzCH,SAAA,CAAUI,IAAA,CAAKH,SAAA,CAAUE,IAAA,EAAMJ,IAAI,CAAC;MACtC,CAAC;MACD;IACF,KAAK;MACHV,SAAA,CAAUG,OAAO,EAAEU,OAAA,CAAQ,UAAUG,QAAA,EAAe;QAClD,IAAIC,UAAA,GAAyB,EAAC;QAC9BD,QAAA,CAASH,OAAA,CAAQ,UAAUK,IAAA,EAAkB;UAC3CD,UAAA,CAAWF,IAAA,CAAKH,SAAA,CAAUM,IAAA,EAAMR,IAAI,CAAC;QACvC,CAAC;QACDC,SAAA,CAAUI,IAAA,CAAKE,UAAU;MAC3B,CAAC;MACD;IACF,KAAK;MACH,OAAOd,OAAA;IACT,KAAK;MACH,IAAIgB,QAAA,GAAiC,CAAC;MACtCnB,SAAA,CAAUG,OAAO,EAAEU,OAAA,CAAQ,UAAUO,KAAA,EAAY;QAC/C,IAAIC,GAAA,GAAMD,KAAA,CAAME,IAAA,CAAK,GAAG;QACxB,IAAI,CAACC,MAAA,CAAOC,SAAA,CAAUC,cAAA,CAAeC,IAAA,CAAKP,QAAA,EAAUE,GAAG,GAAG;UACxDV,SAAA,CAAUI,IAAA,CAAKK,KAAK;UACpBD,QAAA,CAASE,GAAG,IAAI;QAClB;MACF,CAAC;MACD;IACF;MACE,MAAM,IAAIZ,KAAA,CAAMC,IAAA,GAAO,yBAAyB;EACpD;EAGA,IAAIP,OAAA,CAAQwB,WAAA,EAAa;IACvB,IAAInB,MAAA,KAAW,MAAM;MACnBL,OAAA,CAAQwB,WAAA,GAAchB,SAAA;MACtB,OAAOR,OAAA;IACT;IACA,OAAO;MAAEO,IAAA;MAAYiB,WAAA,EAAahB;IAAU;EAC9C,OAAO;IACL,IAAIH,MAAA,KAAW,MAAM;MACnBL,OAAA,CAAQyB,QAAA,CAASD,WAAA,GAAchB,SAAA;MAC/B,OAAOR,OAAA;IACT;IACA,OAAOJ,OAAA,CAAQ;MAAEW,IAAA;MAAYiB,WAAA,EAAahB;IAAU,GAAGR,OAAA,CAAQ0B,UAAA,EAAY;MACzEC,IAAA,EAAM3B,OAAA,CAAQ2B,IAAA;MACdC,EAAA,EAAI5B,OAAA,CAAQ4B;IACd,CAAC;EACH;AACF;AAUA,SAASnB,UAAUE,IAAA,EAAkBJ,IAAA,EAAc;EACjD,IAAIsB,MAAA,GAAShC,SAAA,CAAUc,IAAI;EAE3B,IAAIkB,MAAA,CAAO1B,MAAA,KAAW,KAAK,CAAC2B,MAAA,CAAOD,MAAA,CAAO,CAAC,GAAGA,MAAA,CAAO,CAAC,CAAC,GAAG,OAAOA,MAAA;EAEjE,IAAIE,SAAA,GAAY,EAAC;EACjB,IAAIC,YAAA,GAAeH,MAAA,CAAO1B,MAAA,GAAS;EACnC,IAAI8B,eAAA,GAAkBF,SAAA,CAAU5B,MAAA;EAEhC4B,SAAA,CAAUnB,IAAA,CAAKiB,MAAA,CAAO,CAAC,CAAC;EACxB,SAASK,CAAA,GAAI,GAAGA,CAAA,GAAIF,YAAA,EAAcE,CAAA,IAAK;IACrC,IAAIC,cAAA,GAAiBJ,SAAA,CAAUA,SAAA,CAAU5B,MAAA,GAAS,CAAC;IACnD,IACE0B,MAAA,CAAOK,CAAC,EAAE,CAAC,MAAMC,cAAA,CAAe,CAAC,KACjCN,MAAA,CAAOK,CAAC,EAAE,CAAC,MAAMC,cAAA,CAAe,CAAC,GAEjC,cACG;MACHJ,SAAA,CAAUnB,IAAA,CAAKiB,MAAA,CAAOK,CAAC,CAAC;MACxBD,eAAA,GAAkBF,SAAA,CAAU5B,MAAA;MAC5B,IAAI8B,eAAA,GAAkB,GAAG;QACvB,IACEG,oBAAA,CACEL,SAAA,CAAUE,eAAA,GAAkB,CAAC,GAC7BF,SAAA,CAAUE,eAAA,GAAkB,CAAC,GAC7BF,SAAA,CAAUE,eAAA,GAAkB,CAAC,CAC/B,GAEAF,SAAA,CAAUM,MAAA,CAAON,SAAA,CAAU5B,MAAA,GAAS,GAAG,CAAC;MAC5C;IACF;EACF;EACA4B,SAAA,CAAUnB,IAAA,CAAKiB,MAAA,CAAOA,MAAA,CAAO1B,MAAA,GAAS,CAAC,CAAC;EACxC8B,eAAA,GAAkBF,SAAA,CAAU5B,MAAA;EAG5B,KACGI,IAAA,KAAS,aAAaA,IAAA,KAAS,mBAChCuB,MAAA,CAAOD,MAAA,CAAO,CAAC,GAAGA,MAAA,CAAOA,MAAA,CAAO1B,MAAA,GAAS,CAAC,CAAC,KAC3C8B,eAAA,GAAkB,GAClB;IACA,MAAM,IAAI3B,KAAA,CAAM,iBAAiB;EACnC;EAEA,IAAIC,IAAA,KAAS,gBAAgB0B,eAAA,GAAkB,GAAG;IAChD,OAAOF,SAAA;EACT;EAEA,IACEK,oBAAA,CACEL,SAAA,CAAUE,eAAA,GAAkB,CAAC,GAC7BF,SAAA,CAAUE,eAAA,GAAkB,CAAC,GAC7BF,SAAA,CAAUE,eAAA,GAAkB,CAAC,CAC/B,GAEAF,SAAA,CAAUM,MAAA,CAAON,SAAA,CAAU5B,MAAA,GAAS,GAAG,CAAC;EAE1C,OAAO4B,SAAA;AACT;AAUA,SAASD,OAAOQ,GAAA,EAAeC,GAAA,EAAe;EAC5C,OAAOD,GAAA,CAAI,CAAC,MAAMC,GAAA,CAAI,CAAC,KAAKD,GAAA,CAAI,CAAC,MAAMC,GAAA,CAAI,CAAC;AAC9C;AAYA,SAASH,qBAAqBI,KAAA,EAAiBC,GAAA,EAAeC,KAAA,EAAiB;EAC7E,IAAIC,CAAA,GAAID,KAAA,CAAM,CAAC;IACbE,CAAA,GAAIF,KAAA,CAAM,CAAC;EACb,IAAIG,MAAA,GAASL,KAAA,CAAM,CAAC;IAClBM,MAAA,GAASN,KAAA,CAAM,CAAC;EAClB,IAAIO,IAAA,GAAON,GAAA,CAAI,CAAC;IACdO,IAAA,GAAOP,GAAA,CAAI,CAAC;EAEd,IAAIQ,GAAA,GAAMN,CAAA,GAAIE,MAAA;EACd,IAAIK,GAAA,GAAMN,CAAA,GAAIE,MAAA;EACd,IAAIK,GAAA,GAAMJ,IAAA,GAAOF,MAAA;EACjB,IAAIO,GAAA,GAAMJ,IAAA,GAAOF,MAAA;EACjB,IAAIO,KAAA,GAAQJ,GAAA,GAAMG,GAAA,GAAMF,GAAA,GAAMC,GAAA;EAE9B,IAAIE,KAAA,KAAU,GAAG,OAAO,eACfC,IAAA,CAAKC,GAAA,CAAIJ,GAAG,KAAKG,IAAA,CAAKC,GAAA,CAAIH,GAAG,GACpC,OAAOD,GAAA,GAAM,IAAIN,MAAA,IAAUF,CAAA,IAAKA,CAAA,IAAKI,IAAA,GAAOA,IAAA,IAAQJ,CAAA,IAAKA,CAAA,IAAKE,MAAA,MAC3D,OAAOO,GAAA,GAAM,IAAIN,MAAA,IAAUF,CAAA,IAAKA,CAAA,IAAKI,IAAA,GAAOA,IAAA,IAAQJ,CAAA,IAAKA,CAAA,IAAKE,MAAA;AACrE;AAGA,IAAOU,yBAAA,GAAQzD,WAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}